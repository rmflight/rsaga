

# SAGA

Simulated Annealing / Genetic Algorithm.

```{r initLib}
library(saga)
```


## Test Functions

As an initial test function, we will use a multi-linear regression that is dependent on 8 different parameters. This function is taken from the [NIST website](http://www.itl.nist.gov/div898/strd/nls/data/LINKS/v-gauss3.shtml).

```{r setUpQuery}
betaValues <- c(9.8940368970E+01,
                1.0945879335E-02,
                1.0069553078E+02,
                1.1163619459E+02,
                2.3300500029E+01,
                7.3705031418E+01,
                1.4776164251E+02,
                1.9668221230E+01)

betaSD <- c(5.3005192833E-01,
            1.2554058911E-04,
            8.1256587317E-01,
            3.5317859757E-01,
            3.6584783023E-01,
            1.2091239082E+00,
            4.0488183351E-01,
            3.7806634336E-01)

fx <- function(x, beta){
  beta[1] * exp(-1 * beta[2] * x) + 
  beta[3] * exp(-1 * (x - beta[4])^2 / beta[5]^2) + 
  beta[6] * exp(-1 * (x - beta[7])^2 / beta[8]^2)
}

x <- seq(1, 250, 1)
y <- fx(x, betaValues)
plot(x, y)
```

Our evaluation criteria is **how** different is a new set of `y` based on our candidate `beta` values. Note that this energy function is specific to our current problem.

```{r energyFunction}
energyFunc <- function(newBeta){
  orgBeta <- c(9.8940368970E+01,
                1.0945879335E-02,
                1.0069553078E+02,
                1.1163619459E+02,
                2.3300500029E+01,
                7.3705031418E+01,
                1.4776164251E+02,
                1.9668221230E+01)
  fx <- function(x, beta){
    beta[1] * exp(-1 * beta[2] * x) + 
    beta[3] * exp(-1 * (x - beta[4])^2 / beta[5]^2) + 
    beta[6] * exp(-1 * (x - beta[7])^2 / beta[8]^2)
  }
  x <- seq(1, 250, 1)
  org <- fx(x, orgBeta)
  new <- fx(x, newBeta)
  
  nObs <- length(org)
  return((sum((org - new)^2)))
}
```


And our values for each value of beta will be drawn uniformly from a distribution with a range of 0 to 200. The neighbor values will be based on the current values, but the standard deviation will be adjusted based on the current temperature and alpha.

```{r initPop}
neighborFunction <- function(currentPopulation, useSD, currentTemperature, alpha){
  # an alpha of 0 means temperature has no effect
  if (alpha == 0){
    scaleVariance <- 1
    tmpSD <- useSD
  } else {
    scaleVariance <- currentTemperature * alpha / length(currentPopulation)
    tmpSD <- useSD * scaleVariance
  }
  newPopulation <- rnorm(length(currentPopulation), mean=currentPopulation, sd=tmpSD)
  newPopulation[newPopulation < 0] <- 0
  return(newPopulation)
}
```


Lets write a simple simulated annealing algorithm.


```{r tryitOut}
library(functional)
initPop <- rnorm(8, mean=betaValues, sd=0.2*betaValues)
initPop[(initPop < 0)] <- 0
useSD <- 0.2 * betaValues

tmpNeighbor <- Curry(neighborFunction, useSD=useSD)

outSA <- sa(initPop, energyFunc, tmpNeighbor, 300, 0.005, alpha=0.01, nTry=Inf)
plot(outSA$allEnergy)
plot(log10(outSA$allEnergy))

y2 <- fx(x, outSA$lastSolution)
plot(x,y)
plot(x, y2)
```

```{r try50, eval=FALSE}
library(snowfall)
sfInit(parallel=TRUE, cpus=4)

sfLibrary(saga)
sfExport("tmpNeighbor", "energyFunc")

varyInitPop <- lapply(seq(1, 50), function(x){
  rnorm(8, mean=betaValues, sd=0.2*betaValues)
})

outRes <- sfLapply(varyInitPop, function(x){
  sa(x, energyFunc, tmpNeighbor, 300, 0.005, alpha=0.01, nTry=Inf)
})
sfStop()
save(outRes, file="inst/data/sa50Test.RData")
```

```{r checkSASolutions}
bestEnergies <- sapply(outRes, function(x){ x$bestEnergy})
plot(bestEnergies)
bestSol <- lapply(outRes, function(x){x$bestSolution})
bestSol <- do.call(rbind, bestSol)
betaValues
bestSol
plot(log10(bestEnergies))
```

## Other tests

So the above tests are too biased. We start too close to the real answer. So lets try out the built in optimization methods in `R` and see if they actually work, namely the `SANN` method and `Nelder-Mead`.

```{r neldermead}
library(stats)
initGuess <- runif(8, 0, 200)
initGuess[2] <- runif(1)

optNM <- optim(initGuess, energyFunc, method="Nelder-Mead", control=list(trace=1, maxit=1e6))
```

```{r}
library(stats)
initGuess <- runif(8, 0, 200)
initGuess[2] <- runif(1)
optSA <- optim(initGuess, energyFunc, method="SANN", control=list(temp=300, maxit=1e8))
```

