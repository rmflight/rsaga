

# SAGA

Simulated Annealing / Genetic Algorithm.

## Test Functions

As an initial test function, we will use a multi-linear regression that is dependent on 8 different parameters. This function is taken from the [NIST website](http://www.itl.nist.gov/div898/strd/nls/data/LINKS/v-gauss3.shtml).

```{r setUpQuery}
betaValues <- c(9.8940368970E+01,
                1.0945879335E-02,
                1.0069553078E+02,
                1.1163619459E+02,
                2.3300500029E+01,
                7.3705031418E+01,
                1.4776164251E+02,
                1.9668221230E+01)

betaSD <- c(5.3005192833E-01,
            1.2554058911E-04,
            8.1256587317E-01,
            3.5317859757E-01,
            3.6584783023E-01,
            1.2091239082E+00,
            4.0488183351E-01,
            3.7806634336E-01)

fx <- function(x, beta){
  beta[1] * exp(-1 * beta[2] * x) + 
  beta[3] * exp(-1 * (x - beta[4])^2 / beta[5]^2) + 
  beta[6] * exp(-1 * (x - beta[7])^2 / beta[8]^2)
}

x <- seq(1, 250, 1)
y <- fx(x, betaValues)
plot(x, y)
```

Our evaluation criteria is **how** different is a new set of `y` based on our candidate `beta` values. Note that this energy function is specific to our current problem.

```{r energyFunction}
energyFunc <- function(newBeta){
  orgBeta <- c(9.8940368970E+01,
                1.0945879335E-02,
                1.0069553078E+02,
                1.1163619459E+02,
                2.3300500029E+01,
                7.3705031418E+01,
                1.4776164251E+02,
                1.9668221230E+01)
  fx <- function(x, beta){
    beta[1] * exp(-1 * beta[2] * x) + 
    beta[3] * exp(-1 * (x - beta[4])^2 / beta[5]^2) + 
    beta[6] * exp(-1 * (x - beta[7])^2 / beta[8]^2)
  }
  x <- seq(1, 250, 1)
  org <- fx(x, orgBeta)
  new <- fx(x, newBeta)
  
  nObs <- length(org)
  return((sum((org - new)^2)))
}
```


And our values for each value of beta will be drawn uniformly from a distribution with a range of 0 to 200. The neighbor values will be based on the current values, but the standard deviation will be adjusted based on the current temperature and alpha.

```{r initPop}
neighborFunction <- function(currentPopulation, useSD, currentTemperature, alpha){
  # an alpha of 0 means temperature has no effect
  if (alpha == 0){
    scaleVariance <- 1
    tmpSD <- useSD
  } else {
    scaleVariance <- currentTemperature * alpha / length(currentPopulation)
    tmpSD <- useSD * scaleVariance
  }
  newPopulation <- rnorm(length(currentPopulation), mean=currentPopulation, sd=tmpSD)
  newPopulation[newPopulation < 0] <- 0
  return(newPopulation)
}
```


Lets write a simple simulated annealing algorithm.

```{r sa}
#' run simulated annealing
#'
#' @param initialSolution a starting solution
#' @param evalFunction function to evaluate each iteration of the solution
#' @param neighborFunction the function to create a new solution from the current one
#' @param initialTemperature the starting temperature (default is 300)
#' @param deltaTemperature how much to decrease the temperature at each step (default is 1)
#' @param temperatureStep how many steps to go from \code{initialTemperature} to 0 (default is NA), overrides \code{deltaTemperature}
#' @param alpha how much the current temperature affects the neighbor solution
#' @param sameTolerance how similar two iterations have to be to stop
sa <- function(initialSolution, evalFunction, neighborFunction, initialTemperature=300, deltaTemperature=1, temperatureStep=NA, alpha=1, sameTolerance=0.00001, nTry=10000){
  
  if (!is.na(temperatureStep)){
    deltaTemperature <- (initialTemperature - 0) / temperatureStep
  }
  
  currSolution <- initialSolution
  currEnergy <- evalFunction(initialSolution)
  
  bestSolution <- currSolution
  bestEnergy <- currEnergy
  
  currTemp <- initialTemperature
  currTol <- 1
  iTry <- 1
  
  allSolutions <- list()
  allEnergy <- double()
  
  while ((currTemp > 0) && (currTol > sameTolerance) && (iTry < nTry)){
    newSolution <- neighborFunction(currentPopulation=currSolution, currentTemperature=currTemp, alpha=alpha)
    newEnergy <- evalFunction(newSolution)
    
    deltaEnergy <- newEnergy - currEnergy
    
    if (deltaEnergy < 0){
      currTol <- sum((currSolution - newSolution)^2)
      #automatically accept if energy is better
      currSolution <- newSolution
      currEnergy <- newEnergy
      
    } else {
      energyP <- exp((-1 * deltaEnergy) / currTemp) # calculate energy difference
      #browser(expr=TRUE)
      if (runif(1) < energyP){
        currTol <- sum((currSolution - newSolution)^2)
        currSolution <- newSolution
        currEnergy <- newEnergy
        
      }
    }
    
    if (currEnergy < bestEnergy){
      bestSolution <- currSolution
      bestEnergy <- currEnergy
    }
    
    
    currTemp <- currTemp - deltaTemperature
    
    iTry <- iTry + 1
    
    nSol <- length(allSolutions)
    allSolutions[[nSol+1]] <- currSolution
    allEnergy <- c(allEnergy, currEnergy)
    
    print(c(iTry, currTemp, currEnergy))
    #print(currTol)
    #print(currTemp)
    #print(iTry)
    
  }
  return(list(lastSolution=currSolution,
              lastEnergy=currEnergy,
              allSolutions=allSolutions,
              allEnergy=allEnergy,
              nTry=iTry))
}
```

```{r tryitOut}
library(functional)
initPop <- rnorm(8, mean=betaValues, sd=0.2*betaValues)
initPop[(initPop < 0)] <- 0
useSD <- 0.2 * betaValues

tmpNeighbor <- Curry(neighborFunction, useSD=useSD)

outSA <- sa(initPop, energyFunc, tmpNeighbor, 300, 0.005, alpha=0.1, nTry=Inf)
plot(outSA$allEnergy)
plot(log10(outSA$allEnergy))

y2 <- fx(x, outSA$lastSolution)
plot(x,y)
plot(x, y2)
```

